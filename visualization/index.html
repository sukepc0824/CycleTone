<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
    <style>
        canvas {
            border-radius: 50%;
            outline: 50px solid #444;
        }
    </style>
</head>

<body>
    <script>
        const fifthCircleMap = {
            'C': 0, 'G': 1, 'D': 2, 'A': 3, 'E': 4, 'B': 5,
            'F#': 6, 'Gb': 6,
            'Db': 7, 'C#': 7,
            'Ab': 8, 'G#': 8,
            'Eb': 9, 'D#': 9,
            'Bb': 10, 'A#': 10,
            'F': 11,
        };

        const qualities = ['maj', 'min', 'm', 'dim', 'aug'];

        function parseChord(chordStr) {
            const rootMatch = chordStr.match(/^([A-G][b#]?)/);
            if (!rootMatch) return null;

            const rootBase = rootMatch[1];                  // 例: C, Bb, F#
            const rest = chordStr.slice(rootBase.length);   // 例: m7, dim7...

            let attr = null;
            for (const q of qualities) {
                if (rest.startsWith(q)) {
                    attr = q === 'min' ? 'm' : q;
                    break;
                }
            }

            const suffix = attr ? rest.slice(attr.length) : rest;

            const fifthCircleNumber = fifthCircleMap[rootBase];
            if (fifthCircleNumber === undefined) return null;

            const tensions = [];
            const tensionMatch = suffix.match(/\d+/g);
            if (tensionMatch) {
                tensions.push(...tensionMatch.map(Number));
            }

            return {
                root: rootBase,
                attr,
                fifthCircleNumber,
                tensions
            };
        }

        function drawWavyArrow(x1, y1, x2, y2, waveCount = 5, amplitude = 16, arrowSize = 12) {
            let dx = x2 - x1;
            let dy = y2 - y1;
            let length = dist(x1, y1, x2, y2);
            let angle = atan2(dy, dx);

            // 波線の描画
            push();
            translate(x1, y1);
            rotate(angle);
            noFill();
            stroke(255);
            strokeWeight(2);
            beginShape();
            for (let i = 0; i <= waveCount; i++) {
                let t = (i / waveCount) * (length - arrowSize);  // 矢印手前で止める
                let y = sin(i * PI) * amplitude;
                vertex(t, y);
            }
            endShape();

            // >型の矢印
            translate(length, 0);
            rotate(0);
            stroke(255);
            line(0, 0, -arrowSize, -arrowSize / 2);
            line(0, 0, -arrowSize, arrowSize / 2);
            pop();
        }


        class Chords {
            constructor(chords) {
                this.chords = chords
            }

            chordsPredictDataFormat(chords_sample) {
                chords_sample.unshift('<s>')
                const updatedSample = [];
                for (let i = 0; i < chords_sample.length; i++) {
                    updatedSample.push(chords_sample[i]);
                    if (i < chords_sample.length) {
                        updatedSample.push("next");
                    }
                }

                return updatedSample
            }

            next(chords_sample) {
                const updatedSample = this.chordsPredictDataFormat(chords_sample)
                let chords_temp = this.chords;
                for (let i = 0; i < updatedSample.length; i++) {
                    chords_temp = chords_temp[updatedSample[i]]
                }
                let returnData = []
                for (let key in chords_temp) {
                    returnData.push(key, chords_temp[key].value);
                }
                return returnData
            }
            nextChords(chords_sample) {
                return this.next(chords_sample)
                    .reduce((acc, curr, idx, arr) => {
                        if (idx % 2 === 0) {
                            const chordObj = parseChord(curr);
                            if (chordObj) {
                                chordObj.value = arr[idx + 1];
                                acc.push(chordObj);
                            }
                        }
                        return acc;
                    }, []);
            }
            nextKeys(chords_sample) {
                const chordObjs = this.nextChords(chords_sample);
                const fifthCircleNumberMap = {};
                for (const chord of chordObjs) {
                    if (fifthCircleNumberMap[chord.fifthCircleNumber]) {
                        fifthCircleNumberMap[chord.fifthCircleNumber].value += chord.value;
                    } else {
                        fifthCircleNumberMap[chord.fifthCircleNumber] = {
                            value: chord.value,
                            attr: chord.attr === 'm' ? 'minor' : "major"
                        };
                    }
                }
                console.log(fifthCircleNumberMap);
                return Object.entries(fifthCircleNumberMap).map(([f, data]) => ({
                    f,
                    value: data.value,
                    attr: data.attr
                }));
            }
        }

        class Arrow {
            constructor(from, to, value, attr) {
                this.from = from
                this.to = to
                this.value = value
                this.attr = attr;
            }

            get keys_position() {
                let pos = []
                for (let i = 0; i < 12; i++) {
                    let x = -230 * Math.cos((i + 3) * (Math.PI / 6)) + 240
                    let y = -230 * Math.sin((i + 3) * (Math.PI / 6)) + 240
                    pos.push({
                        x: x,
                        y: y
                    })
                }
                return pos
            }

            render() {
                if (this.from != this.to) {
                    let pos = this.keys_position;
                    let x1 = pos[this.from].x,
                        y1 = pos[this.from].y,
                        x2 = pos[this.to].x,
                        y2 = pos[this.to].y,
                        size = 24,
                        waveCount = 4,
                        wavelength = 1,
                        amplitude = 100,
                        resolution = 1;

                    let dx = x2 - x1;
                    let dy = y2 - y1;
                    let len = dist(x1, y1, x2, y2);
                    let angle = atan2(dy, dx);
                    let availableLength = len - size * 0.2;
                    let totalWaveLength = waveCount * wavelength;
                    let scaleFactor = 1;

                    if (availableLength < totalWaveLength) {
                        scaleFactor = availableLength / totalWaveLength; // 波長を縮める
                    }

                    push();
                    translate(x1, y1);
                    rotate(angle);
                    noFill();
                    stroke((this.value * 30) + 40);
                    strokeWeight(2);
                    beginShape();
                    for (let i = 0; i <= resolution; i++) {
                        let t = (i / resolution) * availableLength;
                        let theta = (t / (wavelength * scaleFactor)) * TWO_PI;
                        let fadeRatio = sin((t / availableLength) * PI);
                        let y = sin(theta) * amplitude * fadeRatio;
                        vertex(t, y);
                    }
                    endShape();
                    pop();

                    fill(255);
                    textSize(30);
                    strokeWeight(8);
                    stroke(0);
                    textFont('Helvetica');
                    textAlign(CENTER, CENTER);
                    text(this.value,
                        x2 - cos(angle) * 50,
                        y2 - sin(angle) * 50);

                    push();
                    // 矢印の位置を少し手前にずらして波線と重なるように調整
                    translate(
                        x2 - cos(angle) * size * 0.15,
                        y2 - sin(angle) * size * 0.15
                    );
                    rotate(angle);
                    stroke((this.value * 30) + 40);
                    strokeWeight(2);
                    line(0, 0, -size, -size / 2);
                    line(0, 0, -size, size / 2);
                    pop();

                }
            }
        }

        let isMinorMode = false;
        document.querySelector("body").addEventListener("click", () => {
            isMinorMode = !isMinorMode;
            document.querySelector("canvas").style.backgroundColor = isMinorMode ? "black" : "white";
            document.querySelector("canvas").style.color = isMinorMode ? "white" : "black";
        });


        async function getChords(path) {
            const response = await fetch(path);
            if (!response.ok) {
                throw new Error('Failed to fetch recursive_chords.json');
            }
            const chords = await response.json();
            return chords
        }

        function setup() {
            createCanvas(480, 480);
            background('BLACK');

            fill(0);
        }

        let renderList = []
        function draw() {
            background(0)
            //drawWavyArrow(50, 200, 350, 200);
            if (isMinorMode) {
                renderList.forEach(arrow => {
                    if (arrow.attr === 'minor') {
                        arrow.render();
                    }
                });
            } else {
                renderList.forEach(arrow => {
                    if (arrow.attr === 'major'){
                        arrow.render();
                    };
                });
            }
        }

        (async () => {
            const chords = new Chords(await getChords('/recursive_chords.json'));
            const key = "C";
            const result = chords.nextKeys([key]);
            const n = parseChord(key).fifthCircleNumber;
            for (const key of result) {
                if (key.attr === 'minor') {
                    renderList.push(new Arrow((n) % 12, (key.f-3+12) % 12, Math.ceil(key.value * 100), key.attr));
                } else {
                    renderList.push(new Arrow(n, key.f, Math.ceil(key.value * 100), key.attr));
                }
            }
            console.log(chords.nextChords([key]))
        })();
    </script>
</body>

</html>