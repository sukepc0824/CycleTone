<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="/reset.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="./index.js"></script>
    <script src="./data.js"></script>
    <style>
        main {
            display: flex;
            position: absolute;
            margin-top: 200px;
        }

        body {
            background-color: #555;
        }

        .overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-color: rgba(204, 204, 204, 0);
            z-index: 50;
        }

        canvas {
            border-radius: 50%;
            outline: 50px solid #000000;
            border: none;
            margin: 60px;
            z-index: 100;
            transform: scale(0.7);
        }

        .keys {
            z-index: 100;
            position: absolute;
            width: 580px;
            height: 580px;
            left: 50%;
            top: 50%;
            border-radius: 50%;
            overflow: hidden;
            transform: translate(-50%, -50%);
        }

        .keys button:active {
            background-color: rgb(174, 174, 174);
        }

        .keys button {
            position: absolute;
            width: 154px;
            height: 290px;
            clip-path: polygon(50% 100%, 0 0, 100% 0);
            background-color: rgb(204, 204, 204);
            transform-origin: center bottom;
            left: calc(50% - 80px);
            display: flex;
            color: #050505;
            padding: 30px;
            gap: 4px;
            align-items: center;
            justify-content: top;
            font-size: 16px;
            flex-direction: column;
        }

        .keys button p.sub {
            font-size: 15px;
            opacity: 0.7;
        }
    </style>
</head>

<body>
    <main>
        <div class="keys"></div>
        <div class="overlay"></div>
    </main>
    <script>
        const fifthCircleMap = {
            'C': 0, 'G': 1, 'D': 2, 'A': 3, 'E': 4, 'B': 5,
            'F#': 6, 'Gb': 6,
            'Db': 7, 'C#': 7,
            'Ab': 8, 'G#': 8,
            'Eb': 9, 'D#': 9,
            'Bb': 10, 'A#': 10,
            'F': 11,
        };
        const chords_type = {
            'major': [0, 1, 4],
        }

        const qualities = ['maj', 'min', 'm', 'dim', 'aug'];

        function parseChord(chordStr) {
            const rootMatch = chordStr.match(/^([A-G][b#]?)/);
            if (!rootMatch) return null;

            const rootBase = rootMatch[1];                  // 例: C, Bb, F#
            const rest = chordStr.slice(rootBase.length);   // 例: m7, dim7...

            let attr = null;
            for (const q of qualities) {
                if (rest.startsWith(q)) {
                    attr = q === 'min' ? 'm' : q;
                    break;
                }
            }

            const suffix = attr ? rest.slice(attr.length) : rest;

            const fifthCircleNumber = fifthCircleMap[rootBase];
            if (fifthCircleNumber === undefined) return null;

            const tensions = [];
            const tensionMatch = suffix.match(/\d+/g);
            if (tensionMatch) {
                tensions.push(...tensionMatch.map(Number));
            }

            return {
                root: rootBase,
                attr,
                fifthCircleNumber,
                tensions
            };
        }

        class Chart {
            constructor(data) {
                this.data = data;
            }
            render() {
                angleMode(DEGREES);;
                push();
                translate(240, 240);
                rotate(-105)

                let total = 12;
                let angleStep = 360 / total;
                let outerRadius = 240;

                for (let i = 0; i < total; i++) {
                    let d = this.data[i];
                    if (!d) continue;
                    let f = d.f;
                    let value = d.value;
                    let attr = d.attr;

                    let startAngle = f * angleStep;
                    let endAngle = (f + 1) * angleStep;


                    let innerRadius = map((100 - ((d.value ** 0.6) * 7)), 0, 100, outerRadius * 0.45, outerRadius);

                    fill((d.value * 1.4) ** 1.15 + 100);
                    noStroke();


                    beginShape();
                    for (let a = startAngle; a <= endAngle; a++) {
                        let x = cos(a) * outerRadius;
                        let y = sin(a) * outerRadius;
                        vertex(x, y);
                    }
                    for (let a = endAngle; a >= startAngle; a--) {
                        let x = cos(a) * innerRadius;
                        let y = sin(a) * innerRadius;
                        vertex(x, y);
                    }
                    endShape(CLOSE);

                    let midAngle = startAngle + angleStep / 2;
                    let labelX = cos(midAngle) * (outerRadius + 20);
                    let labelY = sin(midAngle) * (outerRadius + 20);
                    fill(0);
                    textSize(12);
                    text(d.label, labelX, labelY);
                }

                pop();
            }
        }

        class Chords {
            constructor(chords) {
                this.chords = chords
            }
            chordsPredictDataFormat(chords_sample) {
                const updatedSample = ['<s>', ...chords_sample];
                const result = [];

                for (let i = 0; i < updatedSample.length; i++) {
                    result.push(updatedSample[i]);
                    if (i < updatedSample.length) {
                        result.push("next");
                    }
                }

                return result;
            }

            next(chords_sample) {
                const updatedSample = this.chordsPredictDataFormat(chords_sample)
                let chords_temp = this.chords;
                for (let i = 0; i < updatedSample.length; i++) {
                    chords_temp = chords_temp[updatedSample[i]]
                }
                let returnData = []
                for (let key in chords_temp) {
                    returnData.push(key, chords_temp[key].value);
                }
                return returnData
            }

            nextChords(chords_sample) {
                return this.next(chords_sample)
                    .reduce((acc, curr, idx, arr) => {
                        if (idx % 2 === 0) {
                            const chordObj = parseChord(curr);
                            if (chordObj) {
                                chordObj.value = arr[idx + 1];
                                acc.push(chordObj);
                            }
                        }
                        return acc;
                    }, []);
            }

            nextKeys(chords_sample, attr) {
                const chordObjs = this.nextChords(chords_sample);
                const fifthCircleNumberMap = {};
                for (const chord of chordObjs) {
                    if (fifthCircleNumberMap[chord.fifthCircleNumber]) {
                        fifthCircleNumberMap[chord.fifthCircleNumber].value += chord.value;
                    } else {
                        fifthCircleNumberMap[chord.fifthCircleNumber] = {
                            value: chord.value,
                            attr: chord.attr === 'm' ? 'minor' : "major"
                        };
                    }
                }
                let data = Object.entries(fifthCircleNumberMap).map(([f, data]) => ({
                    f : attr === 'minor' ? parseInt(f) - 3 : parseInt(f),
                    value: data.value * 100,
                    attr: data.attr
                }));
                return data.filter(obj => obj.attr === attr);
            }
            nextTensions(chords_sample, key, attr) {
                const chordObjs = this.nextChords(chords_sample);
                return chordObjs
                    .filter(obj => obj.root === key && obj.attr === attr)
                    .map(obj => ({ tensions: obj.tensions, value: obj.value }));
            }
        }


        class Notes {
            constructor(root, attr) {
                this.root = root;//数字
                this.attr = attr;
                this.chord = []
                chords_type[this.attr].forEach((noteIndex, i) => {
                    const note = (this.root + noteIndex)
                    this.chord.push(note)
                });
            }
            render() {
                /*
                this.chord.forEach(note1 => {
                    note1 = (note1 + 12) % 12;
                    let x1 = new Arrow().keys_position_large[note1].x,
                        y1 = new Arrow().keys_position_large[note1].y;
                    this.chord.forEach(note2 => {
                        note2 = (note2 + 12) % 12;
                        if (note1 !== note2) {
                            let x2 = new Arrow().keys_position_large[note2].x,
                                y2 = new Arrow().keys_position_large[note2].y;
                            stroke(200 * random(0.9, 1));
                            strokeWeight(4);
                            line(x1, y1, x2, y2);
                        }
                    })
                })
                    */
            }
        }

        function setup() {
            const canvas = createCanvas(480, 480);
            background('BLACK');
            canvas.parent(document.querySelector('main'));
            fill(0);
        }


        let renderList = []
        function draw() {
            background(0)
            strokeWeight(1);
            noFill();

            if (mode.main === "suggestion") {
                chart.render();
            }
            if (mode.main === "chord") {
                chord.render();
            }

        }


        let buttonList = [];
        let notesList = [1, 3];
        let chart, chord;
        function buttonIn(index) {
            buttonList.push(index);
            chord = new Notes(index, "major");

            if (buttonList.length == 0) {
                mode.main = "suggestion";
            } else {
                mode.main = "chord";
            }
        }

        function buttonOut(index) {
            const buttonIndex = buttonList.indexOf(index);
            if (buttonIndex > -1) {
                buttonList.splice(buttonIndex, 1);
            }
            if (buttonList.length == 0) {
                mode.main = "suggestion";
            } else {
                mode.main = "chord";
            }
        }

        let mode = { main: "suggestion", attr: "major" }
        document.querySelector("body").addEventListener("click", () => {
            const isMinorMode = mode.attr === "minor";
            mode.attr = isMinorMode ? "major" : "minor";
            chart = new Chart(chords.nextKeys(keys, mode.attr))
        });

        const chords = new Chords(data);
        set_keys();
        keys = ["G"]
        console.log(chords.nextKeys(keys,"major"))
        chart = new Chart(chords.nextKeys(keys, mode.attr))
    </script>
</body>

</html>