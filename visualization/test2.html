<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Play</title>
    <link rel="stylesheet" href="/reset.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
    <link href="https://fonts.cdnfonts.com/css/helvlight" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fragment+Mono&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        main {
            display: flex;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(0deg);
            z-index: 1000;
            border-radius: 50%;
            transition: transform 0.3s ease-out;
        }

        * {
            font-family: 'HelvLight';
            font-weight: 300;
            user-select: none !important;
        }

        body {
            background-color: #555;
            margin-top: 400px;
        }

        .overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-color: rgba(0, 0, 0, 0);
            z-index: 1000;
            width: 480px;
            height: 480px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            ;
            border-radius: 50%;
        }

        canvas {
            border-radius: 50%;
            border: none;
            margin: 60px;
            z-index: 100;
        }

        .keys {
            z-index: 100;
            position: absolute;
            width: 580px;
            height: 580px;
            left: 50%;
            top: 50%;
            border-radius: 50%;
            overflow: hidden;
            transform: translate(-50%, -50%) scale(1.4);
        }

        .keys button:active {
            background-color: rgb(174, 174, 174);
        }

        .keys button {
            position: absolute;
            width: 154px;
            height: 290px;
            clip-path: polygon(50% 100%, 0 0, 100% 0);
            background-color: rgb(204, 204, 204);
            transform-origin: center bottom;
            left: calc(50% - 80px);
            display: flex;
            color: #050505;
            padding: 30px;
            gap: 4px;
            align-items: center;
            justify-content: top;
            font-size: 16px;
            flex-direction: column;
        }

        .keys button p.sub {
            font-size: 15px;
            opacity: 0.7;
        }

        .chord-name {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            z-index: 1000;
            font-size: 84px;
            position: absolute;
        }

        .chord-name .tention {
            font-size: 38px;
            margin-left: 4px;
        }


        .edge {
            background-color: #fff;
            width: 0px;
            height: 240px;
            position: absolute;
            left: 50%;
            top: calc(0%);
            transition: all 0.3s ease-out;
            transform: rotate(0deg);
            z-index: 2000;
            transform-origin: bottom center;
        }

        .edge img {
            width: 100px;
            transform: translateY(10px);
        }

        .edge .sub {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .modal {
            background-color: #000000;
            width: 480px;
            height: 480px;
            z-index: 1000;
            /* Adjusted z-index */
            position: absolute;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, 50%);
            color: #fff;
            font-size: 60px;
            transition: transform 0.2s ease;
            overflow: hidden;
        }

        .progression {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 600px;
            white-space: nowrap;
            max-height: 400px;
            overflow-y: scroll;
        }

        span.arrow {
            opacity: 0.6;
        }

        p.border {
            font-size: 20px;
            margin: 5px;
        }

        .modal.active {
            display: flex;
            transform: translate(-50%, -50%);
        }

        .progression span:last-child {
            color: #ff4800;
        }

        .mode {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            z-index: 10000;
            font-size: 28px;
            margin-top: 100px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            opacity: 0.86;
        }

        .mode>div {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .mode img {
            width: 20px;
            height: 25px;
        }

        .notificaiton {
            position: absolute;
            display: none;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            background: #eee;
            font-size: 44px;
            white-space: nowrap;
            padding: 10px 16px;
            border-radius: 10px;
        }

        .screen {
            outline: 50px solid #040404;
            width: 480px;
            height: 480px;
            position: relative;
            overflow: hidden;
            border-radius: 50%;
        }

        .element {
            width: 480px;
            height: 480px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            background-color: #040404;
            border-radius: 50%;
        }

        .compose {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #1f1f1f;
        }

        .compose button.play {
            background-color: #eee;
            color: #000;
            top: 10px;
            padding: 3px 8px;
            left: 50%;
            transform: translateX(-50%);
            position: absolute;
            font-size: 18px;
            border-radius: 20px;
        }

        .list {
            display: flex;
            gap: 10px;
            font-size: 28px;
            flex-wrap: wrap;
            width: 400px;
            margin-top: 29px;
        }

        .list .chord {
            width: 90px;
            height: 90px;
            display: flex;
            background-color: #333;
            align-items: center;
            justify-content: center;
        }

        main {
            cursor: none;
        }

        .progression {
            position: absolute;
        }

        button.close {
            position: absolute;
            top: 0px;
            left: 50%;
            transform: translateX(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 20px 20px;
            width: 100%;
            margin-top: 0px;
            background: none !important;
        }

        button.close img {
            width: 50px;
            position: absolute;
            top: 50%;
            left: 50%;
            opacity: 0.8;
            transform: translate(-50%, -50%);
        }

        .edit {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }

        .modal button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 10px;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #202020;
            border-radius: 50px;
        }

        img {
            margin: 0;
            padding: 0;
            display: block;
        }

        .modal button img {
            height: 26px;
            opacity: 0.8;
        }

        .modal button.play {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 60px;
            font-size: 28px;
            color: #fff;
            border: none;
            cursor: pointer;
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div class="keys"></div>
    <main>
        <div class="screen">
            <div class="compose">
                <button class="play" onclick="chordProgressionPlay()">▶︎ Play</button>
            </div>
            <div class="element">
                <div class="overlay"></div>
                <div class="chord-name"><span class="root"></span><span class="tention"></span></div>
                <div class="edge">
                    <div class="sub">
                        <div class="div"
                            style="width: 22px; height: 22px; border-radius: 50%; background-color: #ff4800;">
                        </div>
                    </div>
                </div>
                <div class="modal">
                    <div class="progression">
                        <p style="display: none;"></p>
                        <div class="list"></div>
                    </div>
                    <button onclick="modalClose()" class="close">
                        <img src="./assets/close.svg">
                    </button>
                    <div class="edit">
                        <button onclick="undo()">
                            <img src="./assets/undo.svg">
                        </button>
                        <button onclick="redo()">
                            <img src="./assets/redo.svg">
                        </button>
                        <button onclick="chord_delete()">
                            <img src="./assets/delete.svg">
                        </button>
                    </div>
                    <button class="play" onclick="chordProgressionPlay()">
                        <img src="./assets/chordplay.svg" alt="">
                    </button>
                </div>
                <div class="mode">
                    <!--<div class="attr"><img src="./assets/major.svg">major</div>-->
                    <div class="key" style="display: none;"><img src="./assets/key.svg">C/Am</div>
                </div>
                <div class="notificaiton">
                </div>
            </div>
        </div>
    </main>
    <script src="./index.js"></script>
    <script src="./data.js"></script>
    <script>
        let mode = { main: "suggestion", attr: "major" }
        let chart, chord, tensionChart;
        let now_key_index = 0;


        function numberToKey(f) {
            if ((5 + now_key_index) % 12 <= f && f <= (7 + now_key_index) % 12) {
                return fifthCircleMapReversed[(f + 9) % 12];
            } else {
                return fifthCircleMapReversed[f];
            }

        }

        function keyToNumber(f) {
            if ((5 + now_key_index) % 12 <= fifthCircleMap[f] && fifthCircleMap[f] <= (7 + now_key_index) % 12) {
                return fifthCircleMap[f] + 3 % 12;
            } else {
                return fifthCircleMap[f];
            }
        }

        const fifthCircleMap = {
            'C': 0,
            'G': 1,
            'D': 2,
            'A': 3,
            'E': 4,
            'B': 5,
            'F#': 6,
            'C#': 7,
            'G#': 8,
            'D#': 9,
            'A#': 10,
            'F': 11,
        };

        const fifthCircleMapReversed = {
            0: 'C',
            1: 'G',
            2: 'D',
            3: 'A',
            4: 'E',
            5: 'B',
            6: 'F#',
            7: 'C#',
            8: 'G#',
            9: 'D#',
            10: 'A#',
            11: 'F',
        };
        const fifthCircleNumberTensionMap = {
            '9': 2,
            '6': 3,
            'M7': 5,
            'aug': 8,
            '7': 10,
            'sus4': 11,
        }
        const fifthCircleNumberTensionMapReversed = {
            2: '9',
            3: '6',
            5: 'M7',
            8: 'aug',
            10: '7',
            11: 'sus4',
        }
        const fifthCircleNumberTensionMapReversedMinor = {
            2: '9',
            3: '6',
            5: 'M7',
            8: 'aug',
            10: '7',
            11: 'sus4',
        }
        const chords_type = {
            'major': [0, 1, 4],
            'minor': [0, 1, 9],
        }

        const qualities = ['maj', 'min', 'm', 'dim', 'aug'];

        function stringifyChord(chordObj) {
            const { root, attr, tensions } = chordObj;
            if (!root) return null;

            let qualityStr = '';
            if (attr === 'minor') {
                qualityStr = 'm'; // または 'min'、必要に応じて切り替え可能
            } else if (attr !== 'major') {
                qualityStr = attr;
            }

            // テンションが null や空なら、何も追加しない
            const tensionStr = tensions ? tensions : '';

            return [root, qualityStr, tensionStr];
        }

        function circleText(array) {
            const composeDiv = document.querySelector('.compose');
            const radius = 216;
            const centerX = composeDiv.offsetWidth / 2;
            const centerY = composeDiv.offsetHeight / 2;

            array.forEach((text, index) => {
                const angle = (((index - 2) / 12)) * 2 * Math.PI; // 配置する角度
                const x = centerX + radius * Math.cos(angle) - 20; // X座標
                const y = centerY + radius * Math.sin(angle) - 20; // Y座標

                const element = document.createElement('div');
                element.style.position = 'absolute';
                element.style.left = `${x}px`;
                element.style.top = `${y}px`;
                element.style.width = '40px';
                element.style.height = '40px';
                element.style.display = 'flex';
                element.style.alignItems = 'center';
                element.style.justifyContent = 'center';
                element.style.color = '#fff';
                element.style.fontSize = '28px';
                element.innerText = text;
                element.style.transform = `rotate(${angle + Math.PI / 2}rad)`; // 回転して中央を向く

                composeDiv.appendChild(element);
            });
            for (let index = 0; index < array.length - 1; index++) {
                const arrow = document.createElement('img');
                arrow.src = './assets/arrow2.svg';
                const radius = 215;
                const angle = (((index - 1.5) / 12)) * 2 * Math.PI; // 配置する角度
                const x = 240 + radius * Math.cos(angle) - 20; // X座標
                const y = 240 + radius * Math.sin(angle) - 10.4; // Y座標
                arrow.style.position = 'absolute';
                arrow.style.display = 'flex';
                arrow.style.alignItems = 'center';
                arrow.style.justifyContent = 'center';
                arrow.style.left = `${x}px`;
                arrow.style.top = `${y}px`;
                arrow.style.transform = `rotate(${angle + Math.PI / 2}rad)`;
                composeDiv.appendChild(arrow);
            }
        }

        function chordProgressionPlay(progression = chord_progression) {
            if (progression.length === 0) return;

            let index = 0;

            function playNextChord() {
                const chordObj = parseChord(progression[index]);
                if (chordObj) {
                    const notes = new Notes(chordObj);
                    if (chordObj.attr === "minor") {
                        triggerChord(notes.notes.map(n => n + 9), notes.root);
                    } else {
                        triggerChord(notes.notes, notes.root);
                    }
                }
                index++;
                if (index < progression.length) {
                    setTimeout(playNextChord, 840);
                } else {
                    setTimeout(() => {
                        releaseChord();
                        document.querySelectorAll('.list .chord').forEach((chordElement, idx) => {
                            if (idx === index - 1) {
                                chordElement.style.backgroundColor = ''; // Reset the previous chord's highlight
                            }
                        });
                    }, 840);
                }
                document.querySelectorAll('.list .chord').forEach((chordElement, idx) => {
                    if (idx === index - 1) {
                        chordElement.style.backgroundColor = '#ff4800'; // Highlight color
                    } else {
                        chordElement.style.backgroundColor = ''; // Reset others
                    }
                });
            }
            playNextChord();
        }


        function parseChord(chordStr) {
            const rootMatch = chordStr.match(/^([A-G][b#]?)/);
            if (!rootMatch) return null;

            const rootBase = rootMatch[1];
            const rest = chordStr.slice(rootBase.length);

            let attr = null;
            let qualityMatched = '';

            for (const q of qualities) {
                if (rest.startsWith(q)) {
                    attr = q === 'min' || q === 'm' ? 'minor' : q;
                    qualityMatched = q;
                    break;
                }
            }

            const suffix = rest.slice(qualityMatched.length);

            const fifthCircleNumber = keyToNumber(rootBase);
            if (fifthCircleNumber === undefined) return null;
            let tensionStr = suffix.trim();


            if (tensionStr.startsWith('M7')) {
                tensionStr = 'M7' + tensionStr.slice(2); // ex: M7b9 → M7b9
            }

            if (!attr) attr = 'major';

            return {
                root: rootBase,
                attr,
                fifthCircleNumber,
                tensions: tensionStr || null
            };
        }

        const volume = new Tone.Volume(-4).toDestination(); // -10dB に設定
        const synth = new Tone.PolySynth(Tone.Synth).connect(volume);


        // 逆引き (note name -> pitch class)
        const nameToPc = Object.fromEntries(Object.entries(fifthCircleMapReversed).map(([k, v]) => [v, Number(k)]));

        // parse note like "C4" or "F#3"
        function parseNoteString(noteStr) {
            const m = noteStr.match(/^([A-G]#?)(-?\d+)$/);
            if (!m) throw new Error("Invalid note string: " + noteStr);
            const name = m[1];
            const octave = parseInt(m[2], 10);
            const pc = nameToPc[name];
            if (pc === undefined) throw new Error("Unknown note name: " + name);
            const semitone = pc + 12 * octave;
            return { name, octave, pc, semitone };
        }

        // format back to "C4"
        function formatNote(pc, octave) {
            const name = fifthCircleMapReversed[(pc + 12) % 12];
            return name + octave;
        }

        function getPrevSemitones(prevChord) {
            if (!prevChord || prevChord.length === 0) return [];
            return prevChord.map(s => parseNoteString(s).semitone).sort((a, b) => a - b);
        }

        function voiceLeadChord(indexArray, prevChord = [], options = {}) {
            const baseOctave = options.baseOctave ?? 4;

            const prevSemitones = getPrevSemitones(prevChord);

            if (prevSemitones.length === 0) {
                return indexArray.map(pc => formatNote(pc, baseOctave));
            }

            const candidatesPerTone = indexArray.map(pc => {
                const candidates = [];
                for (let o = baseOctave - octaveRange; o <= baseOctave + octaveRange; o++) {
                    candidates.push({ pc, octave: o, semitone: pc + 12 * o });
                }
                return candidates;
            });

            const combos = [];
            function buildCombo(i, acc) {
                if (i === candidatesPerTone.length) {
                    combos.push(acc.slice());
                    return;
                }
                for (const cand of candidatesPerTone[i]) {
                    acc.push(cand);
                    buildCombo(i + 1, acc);
                    acc.pop();
                }
            }
            buildCombo(0, []);

            let best = null;
            let bestScore = Infinity;

            for (const combo of combos) {
                const semis = combo.map(c => c.semitone).slice().sort((a, b) => a - b);
                const minLen = Math.min(semi.length ?? semis.length, prevSemitones.length);
                let score = 0;
                for (let i = 0; i < Math.min(semi.length ?? semis.length, prevSemitones.length); i++) {
                }
                const nMatch = Math.min(semis.length, prevSemitones.length);
                for (let i = 0; i < nMatch; i++) {
                    score += Math.abs(semis[i] - prevSemitones[i]);
                }
                if (semis.length > prevSemitones.length) {
                    score += (semis[semis.length - 1] - semis[0]) * 0.1;
                }
                if (score < bestScore) {
                    bestScore = score;
                    best = combo;
                }
            }

            if (!best) {
                return indexArray.map(pc => formatNote(pc, baseOctave));
            }
            const chosenSorted = best.slice().sort((a, b) => a.semitone - b.semitone);
            return chosenSorted.map(c => formatNote(c.pc, c.octave));
        }

        let currentChord = [];

        function convertToNoteArray(indexArray, octave = 4) {
            return indexArray.map(i => {
                const note = fifthCircleMapReversed[(i + 12) % 12];
                if (!note) {
                    throw new Error(`Invalid index: ${i}`);
                }
                return note + octave;
            });
        }

        function triggerChord(indexArray, root) {
            releaseChord();
            Tone.start();
            const baseOctave = 4;
            const ledNotes = voiceLeadChord(indexArray, currentChord, { baseOctave: baseOctave, octaveRange: 1 });
            const rootName = fifthCircleMapReversed[(root + 12) % 12];
            const rootNoteLower = rootName + (baseOctave - 1); // 例: "F3"
            const notesToPlay = [rootNoteLower, ...ledNotes];

            currentChord = notesToPlay.slice().sort((a, b) => parseNoteString(a).semitone - parseNoteString(b).semitone);
            synth.triggerAttack(notesToPlay);
        }

        function releaseChord() {
            synth.triggerRelease(currentChord);
            currentChord = [];
        };

        class Chart {
            constructor(data, isLabel) {
                this.data = data;
                this.isLabel = isLabel;
                this.animProgress = 0; // 0 → 1 に進む
            }

            update() {
                // 徐々に1に近づける（ease-out）
                this.animProgress += (1 - this.animProgress) * 0.08;
            }

            render() {
                this.update();

                noStroke();
                fill(40);
                arc(240, 240, 480, 480, 45, 135);

                /*
                fill("black");
                noStroke()
                circle(240, 240, 200);

                stroke(234);
                strokeWeight(3);
                arc(240, 240, 200, 200, 45, 135);

                stroke(100);
                strokeWeight(3);
                arc(240, 240, 200, 200, 135, 405);
                */

                angleMode(DEGREES);
                push();
                translate(240, 240);
                rotate(-105 - (now_key_index * 30)); // 12分割の最初の位置を上にする & キーに合わせて回転

                let total = 12;
                let angleStep = 360 / total;
                let outerRadius = 240;

                for (let i = 0; i < total; i++) {
                    let d = this.data[i];
                    if (!d) continue;
                    let f = d.f;
                    let value = d.value;

                    let startAngle = f * angleStep;
                    let endAngle = (f + 1) * angleStep;

                    let targetInnerRadius = map((100 - ((value ** 0.6) * 7)), 0, 100, outerRadius * 0.45, outerRadius);

                    let innerRadius = lerp(outerRadius, targetInnerRadius, this.animProgress);

                    fill(105);
                    fill((d.value * 1.4) ** 1.4 + 100);
                    noStroke();
                    strokeWeight(1);
                    stroke(0)

                    beginShape();
                    for (let a = startAngle; a <= endAngle; a++) {
                        let x = cos(a) * outerRadius;
                        let y = sin(a) * outerRadius;
                        vertex(x, y);
                    }
                    for (let a = endAngle; a >= startAngle; a--) {
                        let x = cos(a) * innerRadius;
                        let y = sin(a) * innerRadius;
                        vertex(x, y);
                    }
                    endShape(CLOSE);

                    let midAngle = startAngle + angleStep / 2;
                    let labelX = cos(midAngle) * (outerRadius + 20);
                    let labelY = sin(midAngle) * (outerRadius + 20);
                    fill(0);
                    textSize(12);
                    text(d.label, labelX, labelY);
                }
                pop();
            }
        }
        const sharps = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        function transposeChord(chord, semitones, useFlats = false) {
            const flats = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
            const normFlatToSharp = { "DB": "C#", "EB": "D#", "GB": "F#", "AB": "G#", "BB": "A#", "CB": "B", "FB": "E", "E#": "F", "B#": "C" };
            const pick = useFlats ? (i => flats[i]) : (i => sharps[i]);

            function normNote(s) {
                if (!s) return "";
                s = s.toUpperCase();
                if (s.length > 1 && s[1] === 'B') return normFlatToSharp[s] || s; // Bb -> A#
                if (s.length > 1 && s[1] === '#') return s;
                return s;
            }

            function transposeSingle(root, n) {
                const r = normNote(root);
                const idx = sharps.indexOf(r);
                if (idx === -1) return root; // unknown, return as-is
                const ni = (idx + (n % 12) + 12) % 12;
                return pick(ni);
            }

            // parse chord: root = letter + optional #/b, rest = after root (including slash bass)
            const m = chord.match(/^([A-Ga-g])([#b♯♭]?)(.*)$/);
            if (!m) return chord;
            let [, L, acc, rest] = m;
            if (acc === '♯') acc = '#';
            if (acc === '♭') acc = 'b';
            const root = (L.toUpperCase() + (acc || ""));
            // handle slash bass if present
            const slashIndex = rest.indexOf('/');
            let mainRest = rest;
            let bassPart = "";
            if (slashIndex !== -1) {
                mainRest = rest.slice(0, slashIndex);
                bassPart = rest.slice(slashIndex + 1);
            }

            // transpose root and bass (if any). Bass may itself be a chord like "G#"
            const transRoot = transposeSingle(root, semitones);
            let result = transRoot + mainRest;
            if (bassPart) {
                const bm = bassPart.match(/^([A-Ga-g])([#b♯♭]?)(.*)$/);
                if (bm) {
                    let [, BL, Bacc, Brest] = bm;
                    if (Bacc === '♯') Bacc = '#';
                    if (Bacc === '♭') Bacc = 'b';
                    const bassRoot = BL.toUpperCase() + (Bacc || "");
                    result += "/" + transposeSingle(bassRoot, semitones) + (Brest || "");
                } else {
                    result += "/" + bassPart; // unknown bass format
                }
            }
            return result;
        }


        class Chords {
            constructor(chords) {
                this.chords = chords
            }
            chordsPredictDataFormat(chords_sample) {
                const updatedSample = ['<s>', ...chords_sample];
                const result = [];

                for (let i = 0; i < updatedSample.length; i++) {
                    result.push(updatedSample[i]);
                    if (i < updatedSample.length) {
                        result.push("next");
                    }
                }

                return result;
            }

            next(chords_sample) {
                chords_sample = chords_sample.map(chord => transposeChord(chord, -sharps.indexOf(fifthCircleMapReversed[now_key_index])))
                const updatedSample = this.chordsPredictDataFormat(chords_sample)
                let chords_temp = this.chords;
                for (let i = 0; i < updatedSample.length; i++) {
                    try {
                        if (!chords_temp[updatedSample[i]]) {
                            chords_temp = {};
                            break;
                        }
                    } catch (e) {
                        chords_temp = {};
                        break;
                    }
                    chords_temp = chords_temp[updatedSample[i]]
                }
                let returnData = []
                for (let key in chords_temp) {
                    returnData.push(transposeChord(key, sharps.indexOf(fifthCircleMapReversed[now_key_index])), chords_temp[key].value);
                }
                return returnData
            }

            nextChords(chords_sample) {
                return this.next(chords_sample)
                    .reduce((acc, curr, idx, arr) => {
                        if (idx % 2 === 0) {
                            const chordObj = parseChord(curr);
                            if (chordObj) {
                                chordObj.value = arr[idx + 1];
                                acc.push(chordObj);
                            }
                        }
                        return acc;
                    }, []);
            }

            nextKeys(chords_sample, attr) {
                const chordObjs = this.nextChords(chords_sample);
                console.log(chordObjs)
                const fifthCircleNumberMap = {};
                for (const chord of chordObjs) {
                    if (fifthCircleNumberMap[chord.fifthCircleNumber]) {
                        fifthCircleNumberMap[chord.fifthCircleNumber].value += chord.value;
                    } else {
                        fifthCircleNumberMap[chord.fifthCircleNumber] = {
                            value: chord.value,
                            attr: chord.attr === 'minor' ? 'minor' : "major"
                        };
                    }
                }
                let data = Object.entries(fifthCircleNumberMap).map(function ([f, data]) {
                    if (data.attr === "minor" && !(5+now_key_index <= parseInt(f) + 3 && parseInt(f) + 3 <= 7+now_key_index)) {

                    } else {
                        return (
                            {
                                f: data.attr === "minor" ? (parseInt(f) + 3)%12 : parseInt(f)%12,
                                value: data.value * 100,
                                attr: data.attr
                            })
                    }
                });
                console.log(data)
                return data;
            }

            nextTensions(chords_sample, attr, key) {
                const chordObjs = this.nextChords(chords_sample);

                const tensionMap = {};
                let total = 0;

                for (const chord of chordObjs) {
                    if (chord.root === key && chord.attr === attr) {
                        const tension = chord.tensions || 'no tension';
                        if (!tensionMap[tension]) {
                            tensionMap[tension] = 0;
                        }
                        tensionMap[tension] += chord.value;
                        total += chord.value;
                    }
                }
                return Object.entries(tensionMap).map(([tension, value]) => (
                    {
                        f: fifthCircleNumberTensionMap[tension],
                        value: (value / total) * 100
                    }));
            }
        }

        class Notes {
            constructor(chord) {
                this.chord = chord;
                this.root = keyToNumber(chord.root);
                this.attr = chord.attr;
                this.notes = []
                chords_type[this.attr].forEach((noteIndex, i) => {
                    let note = (this.root + noteIndex)
                    this.notes.push(note)
                });
                if (chord.tensions) {
                    this.notes.push(fifthCircleNumberTensionMap[chord.tensions] + this.root)
                }
                if (this.attr === "minor") {
                    this.notes = this.notes.map(n => (n + 3) % 12)
                }
            }
            get position() {
                let positions = [];
                for (let i = 0; i < 12; i++) {
                    let angle = map(i, 0, 12, 0, 360);
                    let x = cos(angle - 90 - (now_key_index * 30)) * 220 + 240;
                    let y = sin(angle - 90 - (now_key_index * 30)) * 220 + 240;
                    positions.push({ x: x, y: y });
                }
                return positions;
            }
            renderLine() {
                //background(0);
                this.notes.forEach(note1 => {
                    note1 = (note1 + 12) % 12;
                    let x1 = this.position[note1].x,
                        y1 = this.position[note1].y;
                    this.notes.forEach(note2 => {
                        note2 = (note2 + 12) % 12;
                        if (note1 !== note2) {
                            let x2 = this.position[note2].x,
                                y2 = this.position[note2].y;
                            stroke(240 * random(0.94, 1));
                            strokeWeight(3);
                            line(x1, y1, x2, y2);
                        }
                    })
                })

                /*
                let x_p = this.position[this.notes[0]].x,
                    y_p = this.position[this.notes[0]].y;
                    noStroke()
                    fill("#ff4800")
                    circle(x_p,y_p,20)*/
            }
            renderChordName() {
                const chord_name = stringifyChord(this.chord)
                document.querySelector('.chord-name .root').innerHTML = chord_name[0] + chord_name[1]
                document.querySelector('.tention').innerHTML = chord_name[2]
            }
            render() {
                this.renderLine()
                this.renderChordName();
            }
        }

        class TensionChart {
            constructor(data, curChord) {
                this.data = data;
                this.root = keyToNumber(curChord.root);
                this.attr = curChord.attr;
                this.data = Array(12).fill(0);
                data.forEach(d => {
                    if (d && d.f !== undefined) {
                        this.data[d.f] = d.value;
                    }
                });
            }
            render() {
                let angleStep = 360 / 12;
                push();
                translate(240, 240);
                textAlign(CENTER, CENTER);
                for (let i = 0; i < 12; i++) {
                    let value = this.data[i];
                    let angle = i * angleStep + angleStep / 2;
                    if (this.attr === "minor") {
                        angle += 90
                    }
                    angle += this.root * 30
                    let labelRadius = 210;
                    let x = cos(angle - 105) * labelRadius;
                    let y = sin(angle - 105) * labelRadius;

                    push();
                    translate(x, y);
                    textSize(32);
                    noStroke()
                    fill(value * 102 + 100);
                    text(fifthCircleNumberTensionMapReversed[i], 0, 0);
                    pop();
                }

                pop();
            }
        }

        class Line {
            constructor(f_array) {
                this.f_array = f_array;
                this.progress = 0; // 0 → 1
            }

            update() {
                // 徐々に 1 に近づける（ease-out）
                this.progress += (1 - this.progress) * 0.08;
            }

            render() {
                this.update();

                for (let i = 0; i < this.f_array.length - 1; i++) {
                    let f = this.f_array[i];
                    let f2 = this.f_array[i + 1];

                    // 座標変換
                    let angle = map(f, 0, 12, 0, 360);
                    let x1 = cos(angle - 90) * 220 + 240;
                    let y1 = sin(angle - 90) * 220 + 240;

                    let angle2 = map(f2, 0, 12, 0, 360);
                    let x2 = cos(angle2 - 90) * 220 + 240;
                    let y2 = sin(angle2 - 90) * 220 + 240;

                    // progress に応じて線を部分的に描画
                    let xCurrent = lerp(x1, x2, this.progress);
                    let yCurrent = lerp(y1, y2, this.progress);

                    stroke(255);
                    strokeWeight(0);
                    line(x1, y1, xCurrent, yCurrent);
                }
            }
        }


        let lines;
        function setup() {
            const canvas = createCanvas(480, 480);
            canvas.parent(document.querySelector('.element'));
            background(0); // Ensure the background is set
            lines = new Line([]);//C F G Am Dm Em F G C
        }


        let renderList = []
        function draw() {
            background(0); // Clear the canvas each frame
            strokeWeight(1);
            noFill();
            textFont('HelvLight');
            if (chord_progression.length === 0) {
                document.querySelector(".sub .div").style.opacity = 0
            } else {
                document.querySelector(".sub .div").style.opacity = 1
            }
            if (mode.main === "suggestion") {
                document.querySelector(".chord-name").innerHTML = '<span class="root"></span><span class="tention"></span>'
                document.querySelector(".mode").style.display = "flex"
                document.querySelector(".element").style.transform = "translate(-50%, -50%)"
                document.querySelector(".sub .div").style.display = "block"
                chart.render();
                lines.render();
            }
            if (mode.main === "chord") {
                tensionChart.render();
                chord.render();
                document.querySelector(".mode").style.display = "none"
                document.querySelector(".sub .div").style.display = "none"
            }
            if (mode.main === 'compose') {
                //document.querySelector(".element").style.transform = "translate(-50%, -50%) scale(0.8)";
                document.querySelector(".sub .div").style.display = "none"
                document.querySelector(".mode").style.display = "none"
            }

        }

        let buttonList = [];
        // curChordとcurChordHistoryを初期化
        let curChord = {
            root: null,
            attr: null,
            tensions: null
        };
        let curChordHistory = []; // curChordの履歴を保存する配列

        // curChordを更新する関数
        function updateCurChord(newChord) {
            curChord = { ...newChord }; // curChordを更新
            curChordHistory.push({ ...curChord }); // 履歴に追加
        }

        function buttonIn(index) {
            buttonList.push(index);
            let tensions;

            if (buttonList.length == 2) {
                if (curChord.attr === "minor") {
                    tensions = (index - 3 - keyToNumber(curChord.root) + 12) % 12;
                } else {
                    tensions = (index - keyToNumber(curChord.root) + 12) % 12;
                }
                curChord.tensions = fifthCircleNumberTensionMapReversed[tensions];
            } else if (buttonList.length < 2) {
                curChord.root = numberToKey(index);
                curChord.tensions = null;
                if (index >= (5 + now_key_index) % 12 && index <= (7 + now_key_index) % 12) {
                    curChord.attr = "minor";
                } else {
                    curChord.attr = "major";
                }
                tensionChart = new TensionChart(
                    chords.nextTensions(chord_progression, mode.attr, numberToKey(index)).map(function (data) {
                        if (data.f === undefined) return null;
                        return {
                            f: data.f,
                            value: data.value
                        };
                    }),
                    curChord
                );
            }

            updateCurChord(curChord);

            chord = new Notes(curChord);

            if (buttonList.length == 0) {
                mode.main = "suggestion";
            } else {
                mode.main = "chord";
                if (chord.attr === "minor") {
                    triggerChord(chord.notes.map(n => n + 9), chord.root);
                } else {
                    triggerChord(chord.notes, chord.root);
                }
            }
        }

        function buttonOut(index) {
            const buttonIndex = buttonList.indexOf(index);
            if (buttonIndex > -1) {
                buttonList.splice(buttonIndex, 1);
            }
            if (buttonList.length == 0) {
                mode.main = "suggestion";
                releaseChord();
            } else {
                mode.main = "chord";
            }
        }

        // 履歴の取得例
        function getLastChord() {
            if (curChordHistory.length > 0) {
                return curChordHistory[curChordHistory.length - 1]; // 履歴の最後の要素を取得
            }
            return null;
        }

        function buttonInDouble() {
            let index = keyToNumber(curChord.root)
            if (curChord.attr === "minor") {
                index = (index + 3) % 12
            }
            let currentRotation = parseFloat(document.querySelector(".edge").style.transform.replace(/[^-?\d.]/g, '')) || 0;
            let targetRotation = (index - now_key_index) * 30;
            let deltaRotation = ((targetRotation - currentRotation + 540) % 360) - 180; // Shortest path calculation
            document.querySelector(".edge").style.transform = `rotate(${currentRotation + deltaRotation}deg)`;
            chord_progression.push(stringifyChord(curChordHistory[curChordHistory.length - 2]).join(""))
            chart = new Chart(chords.nextKeys(chord_progression, mode.attr))
            lines = new Line(chord_progression.map(chord => {
                const chordObj = parseChord(chord);
                return chordObj ? chordObj.fifthCircleNumber : null;
            }).filter(f => f !== null));
        }


        function updateKeyNotification() {
            const majorName = numberToKey(now_key_index);
            const minorName = numberToKey((now_key_index + 6) % 12); // 相対短調（長調から9半音上）
            const el = document.querySelector('.notificaiton');
            el.innerText = `Key: ${majorName}/${minorName}m`;
            el.style.display = 'block';
            setTimeout(() => {
                el.style.display = 'none';
            }, 1800);

            const keyDiv = document.querySelector('.mode .key');
            if (keyDiv) keyDiv.innerHTML = `<img src='./assets/key.svg'> ${majorName}/${minorName}`;
        }

        function buttonInTriple(key) {
            let prev = sharps.indexOf(fifthCircleMapReversed[now_key_index])
            now_key_index = key;
            updateKeyNotification();
            document.querySelector('main').style.transform = `translate(-50%, -50%) rotate(${now_key_index * 30}deg)`;

            chord_progression = chord_progression.map(chord => transposeChord(chord, sharps.indexOf(fifthCircleMapReversed[now_key_index]) - prev))
            chart = new Chart(chords.nextKeys(chord_progression, mode.attr))
            updateChordList(chord_progression)
        }

        function chord_delete() {
            chord_progression_temp = []
            chart = new Chart(chords.nextKeys(chord_progression_temp, mode.attr))
            updateChordList(chord_progression_temp)
        }
        let chord_progression_temp = []
        function undo() {
            chord_progression_temp = chord_progression_temp.slice(0, -1)
            updateChordList(chord_progression_temp)
        }

        function redo() {
            chord_progression_temp = chord_progression.slice(0, chord_progression_temp.length + 1)
            updateChordList(chord_progression_temp)
        }

        function modalClose() {
            document.querySelector('.modal').classList.remove('active')
            chord_progression = chord_progression_temp
            chart = new Chart(chords.nextKeys(chord_progression, mode.attr))
            updateChordList(chord_progression)
            mode.main = 'suggestion'
        }


        // 初期表示
        updateKeyNotification();

        /*
        document.querySelector(".overlay").addEventListener("click", () => {
            const isMinorMode = mode.attr === "minor";
            mode.attr = isMinorMode ? "major" : "minor";
            chart = new Chart(chords.nextKeys(chord_progression, mode.attr))
            document.querySelector(".mode .attr").innerHTML = `<img src="./assets/${mode.attr}.svg">${mode.attr}`
        });*/
        
        setInterval(() => {
            localStorage.setItem('chord_progression', JSON.stringify(chord_progression));
        }, 30000);
        const chords = new Chords(data);
        chord_progression = []
        chart = new Chart(chords.nextKeys(chord_progression, mode.attr))
        set_keys();
        circleText(chord_progression)
    </script>
</body>

</html>
